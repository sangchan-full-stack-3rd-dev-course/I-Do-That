# 일자 : 24.05.11 ~ 24.05.12

## 1. 오늘 내용

### (1) db 모듈화
- 이전 강의에서 배운 db 사용을 위한 코드 중 connection을 모듈화 함.
- 이를 통해서 다른 파일에서도 DB 접근이 가능해짐.

### (2) 기존 기능에 DB 적용
- 기존에는 map 자료구조에 임시로 데이터를 담아서 기능들을 구현했음.
- db 모듈을 사용하여 map 관련 기능을 DB 연동되도록 수정.
- 실제로 DB에 조회,생성,수정,삭제가 가능해짐.

### (3) 리펙토링
- 기존에는 한 줄에 너무 많은 코드가 있어 보기 불편했음.
- 따라서 query에 들어갈 파라미터들을 변수로 선언함.
- 들어갈 값들을 각각의 변수로 정의.
- 이를 통해 코드의 가시성 증가.

## 2. 실습

### (1) 쿼리 포맷 파일을 추가
- 쿼리 형식 포맷을 따로 파일로 관리.
- 쿼리를 추가할 때마다 해당 파일에서 복붙하면 됨.
- 필요한 내용은 각 코드에서 구현하기
```sh
    # ex) `SELECT * FROM users WHERE id = ?`
    let sql = '';
    # ex) ["test_id"]
    let data = [];
    # ex) () => { res.json(data); }
    let func = (err, results, fields)=>{}
    
    conn.query(sql,data,func);
```

### (2) Result 다시 생각해보기
- msg와 status code를 다루기 위한 클래스 Result를 만듦.
- Result에 각 에러코드에 해당하는 status code를 처리하기 위한 메소드 생성.
- 실제로 가시성이 좋아졌으나, 클라이언트에 응답하는 코드의 가시성은 좋지 않은 것 같음.
```sh
    let result = new Result();
    # ...
    res.status(result.code).json({
        message : result.msg
        # 추가 데이터를 보내면 여기에 추가함
    });
```
- 좀 더 가시성을 올리려면 다음과 같은 느낌으로 수정하면 어떨까?
```sh
    # Result에 data field 추가.
    constructor(){
        this.code = 200;
        this.res = {"msg": "", "data":{}};
    }

    # 성공 메소드에 data 관련 로직 추가
    success(code, msg, data){
        this.code = code;
        this.res.msg = msg;
        this.res.data = data;
    }

    # 이후 응답 코드를 다음과 같이 변경
    res.status(result.code).json(result.res);
```
- 좀 더 고민해봐야 할 듯함.